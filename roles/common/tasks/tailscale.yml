# todo: Add building from source option for restricted environments and geo-blocked hosts
# todo: Add options for different installation methods (e.g., package manager, manual download)
# todo: Add support for different Tailscale versions and channels (stable, beta, etc.)
# todo: Add more detailed logging and error handling for installation steps
# todo: Add idempotency checks to avoid unnecessary reinstalls
# todo: Add documentation for how to use and configure Tailscale with this role
# todo: Consider adding options for configuring Tailscale settings (e.g., DNS, routes) via vars
# todo: Add hadler to restart tailscaled service if config changes
# todo: Add handler to clean up old Tailscale versions if needed
# todo: Add handler to restart headscale if it used as control plane due to acls non-idempotency
# todo: Add devug info about tailscale status and ips, routes after installation
# todo: Add checksum/signature verification and version pinning for installer downloads
# todo: Make tailscale up/reset/advertise flags configurable and skip when prefs already match
# Detect existing installations so we can skip reinstalling binaries
- name: Check current Tailscale installation state
  ansible.builtin.command: tailscale version
  register: common_tailscale_install_check
  changed_when: false
  failed_when: false

- name: Set Tailscale install flags
  ansible.builtin.set_fact:
    common_tailscale_is_installed: "{{ (common_tailscale_install_check.rc | default(1)) == 0 }}"
    common_tailscale_needs_install: "{{ not ((common_tailscale_install_check.rc | default(1)) == 0) }}"

- name: Load Tailscale auth key from vault if available
  ansible.builtin.set_fact:
    common_tailscale_authkey: "{{ vault_common_tailscale_authkey }}"
  when: vault_common_tailscale_authkey is defined
  no_log: true

- name: Ensure Tailscale auth key is provided
  ansible.builtin.assert:
    that:
      - common_tailscale_authkey | default('') | length > 0
    fail_msg: "common_tailscale_authkey is required. Store it in group_vars/all/vault.yml as vault_common_tailscale_authkey."

# --- Kernel/network prerequisites ---
- name: Ensure ethtool is installed (for GRO tweaks)
  ansible.builtin.apt:
    name: ethtool
    state: present
    update_cache: false
  when: ansible_facts.os_family == "Debian"

- name: Enable IP forwarding for exit-node support
  ansible.builtin.sysctl:
    name: "{{ item.name }}"
    value: "{{ item.value }}"
    state: present
    reload: true
  loop:
    - { name: "net.ipv4.ip_forward", value: "1" }
    - { name: "net.ipv6.conf.all.forwarding", value: "1" }
  when: ansible_facts.os_family == "Debian"

- name: Capture current GRO settings on primary interface
  ansible.builtin.command: ethtool -k {{ ansible_default_ipv4.interface }}
  register: common_tailscale_ethtool_features
  changed_when: false
  failed_when: false
  when: ansible_default_ipv4 is defined

- name: Enable UDP GRO forwarding when disabled
  ansible.builtin.command: ethtool -K {{ ansible_default_ipv4.interface }} rx-udp-gro-forwarding on
  when:
    - ansible_default_ipv4 is defined
    - common_tailscale_ethtool_features.stdout is defined
    - "'rx-udp-gro-forwarding: on' not in common_tailscale_ethtool_features.stdout"

- name: Enable generic receive offload (GRO) when disabled
  ansible.builtin.command: ethtool -K {{ ansible_default_ipv4.interface }} gro on
  when:
    - ansible_default_ipv4 is defined
    - common_tailscale_ethtool_features.stdout is defined
    - "'generic-receive-offload: on' not in common_tailscale_ethtool_features.stdout"

# --- Manual install flow for geo-restricted (RU) hosts ---
- name: Determine manual Tailscale architecture (RU hosts)
  ansible.builtin.set_fact:
    common_tailscale_manual_arch: "{{ common_tailscale_arch_map[ansible_architecture] | default(ansible_architecture) }}"
  when:
    - "'region_ru' in group_names"
    - common_tailscale_needs_install | default(true)

- name: Fetch latest Tailscale metadata (RU hosts)
  ansible.builtin.uri:
    url: "{{ common_tailscale_manual_metadata_url }}"
    method: GET
    return_content: true
    status_code: 200
  check_mode: false
  register: common_tailscale_manual_metadata
  when:
    - "'region_ru' in group_names"
    - common_tailscale_needs_install | default(true)

- name: Determine manual Tailscale version info (RU hosts)
  vars:
    metadata_json: >-
      {{
        common_tailscale_manual_metadata.json
          if (common_tailscale_manual_metadata.json is defined and common_tailscale_manual_metadata.json is not none)
          else (common_tailscale_manual_metadata.content | default('{}', true) | string | from_json)
      }}
  ansible.builtin.set_fact:
    common_tailscale_manual_metadata_json: "{{ metadata_json }}"
    common_tailscale_manual_tarball: "{{ metadata_json.get('Tarballs', {}).get(common_tailscale_manual_arch, '') }}"
    common_tailscale_manual_version: "{{ metadata_json.get('Version') | default('unknown') }}"
  when:
    - "'region_ru' in group_names"
    - common_tailscale_needs_install | default(true)

- name: Ensure manual tarball is available for architecture (RU hosts)
  ansible.builtin.fail:
    msg: "No Tailscale tarball available for architecture {{ common_tailscale_manual_arch }}."
  when:
    - "'region_ru' in group_names"
    - common_tailscale_needs_install | default(true)
    - common_tailscale_manual_tarball | default('') == ''

- name: Determine manual install temp directory (RU hosts)
  ansible.builtin.set_fact:
    common_tailscale_manual_tmp_dir: "{{ ansible_env.TMPDIR | default('/tmp') }}"
  when:
    - "'region_ru' in group_names"
    - common_tailscale_needs_install | default(true)

- name: Prepare manual Tailscale paths (RU hosts)
  ansible.builtin.set_fact:
    common_tailscale_manual_archive: "{{ common_tailscale_manual_tarball }}"
    common_tailscale_manual_archive_path: "{{ common_tailscale_manual_tmp_dir }}/{{ common_tailscale_manual_tarball }}"
    common_tailscale_manual_extract_dir: "{{ common_tailscale_manual_tmp_dir }}/{{ common_tailscale_manual_tarball | regex_replace('\\.tgz$', '') }}"
    common_tailscale_manual_download_url: "{{ common_tailscale_manual_download_base }}/{{ common_tailscale_manual_tarball }}"
  when:
    - "'region_ru' in group_names"
    - common_tailscale_needs_install | default(true)

- name: Set local control-plane archive path (RU hosts)
  ansible.builtin.set_fact:
    common_tailscale_manual_archive_local_path: "{{ common_control_base_dir }}/downloads/{{ common_tailscale_manual_archive }}"
  when:
    - "'region_ru' in group_names"
    - common_tailscale_needs_install | default(true)

# Provide a summary when running with --check so operators know the intended actions
- name: Show manual Tailscale install plan (RU hosts, check mode)
  ansible.builtin.debug:
    msg: >
      Would download {{ common_tailscale_manual_archive }} from
      {{ common_tailscale_manual_download_url }} and install binaries
      into /usr/local/bin on {{ inventory_hostname }}.
  when:
    - "'region_ru' in group_names"
    - ansible_check_mode
    - common_tailscale_needs_install | default(true)

# Execute the manual installation with rollback safeguards
- name: Install Tailscale manually on RU hosts
  when:
    - "'region_ru' in group_names"
    - common_tailscale_needs_install | default(true)
    - not ansible_check_mode
  block:
    - name: Fetch manual Tailscale archive with remote-first fallback
      block:
        # todo: Validate archive checksum/signature before extracting
        - name: Download manual Tailscale archive on remote host
          ansible.builtin.get_url:
            url: "{{ common_tailscale_manual_download_url }}"
            dest: "{{ common_tailscale_manual_archive_path }}"
            mode: "0644"
        - name: Note download source (remote)
          ansible.builtin.set_fact:
            common_tailscale_manual_download_source: remote
      rescue:
        - name: Ensure local download dir exists
          ansible.builtin.file:
            path: "{{ common_control_base_dir }}/downloads"
            state: directory
            mode: "0700"
          delegate_to: localhost
          run_once: true
          become: false

        - name: Download manual Tailscale archive on control host
          ansible.builtin.get_url:
            url: "{{ common_tailscale_manual_download_url }}"
            dest: "{{ common_tailscale_manual_archive_local_path }}"
            mode: "0644"
          delegate_to: localhost
          become: false

        - name: Copy manual Tailscale archive from control host to remote
          ansible.builtin.copy:
            src: "{{ common_tailscale_manual_archive_local_path }}"
            dest: "{{ common_tailscale_manual_archive_path }}"
            mode: "0644"

        - name: Note download source (control)
          ansible.builtin.set_fact:
            common_tailscale_manual_download_source: control

    - name: Extract manual Tailscale archive
      ansible.builtin.unarchive:
        src: "{{ common_tailscale_manual_archive_path }}"
        dest: "{{ common_tailscale_manual_tmp_dir }}"
        remote_src: true
        creates: "{{ common_tailscale_manual_extract_dir }}/tailscale"

    - name: Install Tailscale binaries manually
      ansible.builtin.copy:
        src: "{{ common_tailscale_manual_extract_dir }}/{{ item.src }}"
        dest: "/usr/local/bin/{{ item.dest }}"
        owner: root
        group: root
        mode: "0755"
        remote_src: true
      loop:
        - { src: "tailscale", dest: "tailscale" }
        - { src: "tailscaled", dest: "tailscaled" }

    - name: Install Tailscale systemd unit file
      ansible.builtin.copy:
        src: "{{ common_tailscale_manual_extract_dir }}/systemd/tailscaled.service"
        dest: /etc/systemd/system/tailscaled.service
        owner: root
        group: root
        mode: "0644"
        remote_src: true

    - name: Install tailscaled defaults file
      ansible.builtin.copy:
        dest: /etc/default/tailscaled
        owner: root
        group: root
        mode: "0644"
        content: |
          # Managed by Ansible. Override tailscaled environment variables here.
          # Use 0 to let tailscaled choose a random available port.
          PORT=0
          FLAGS=

    - name: Create Tailscale data directories
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        owner: root
        group: root
        mode: "0755"
      loop:
        - /var/lib/tailscale
        - /run/tailscale

    - name: Ensure tailscale binaries are available in /usr/sbin
      ansible.builtin.file:
        src: "/usr/local/bin/{{ item }}"
        dest: "/usr/sbin/{{ item }}"
        state: link
      loop:
        - tailscale
        - tailscaled

    - name: Enable tailscaled service
      ansible.builtin.systemd:
        name: tailscaled
        enabled: true
        state: started
        daemon_reload: true

    - name: Verify manual Tailscale installation
      ansible.builtin.command: tailscale version
      register: common_tailscale_manual_version_check
      changed_when: false

  rescue:
    - name: Stop tailscaled after failed manual install
      ansible.builtin.systemd:
        name: tailscaled
        state: stopped
        enabled: false
        daemon_reload: true
      failed_when: false

    - name: Remove installed files after failed manual install
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop:
        - /usr/local/bin/tailscale
        - /usr/local/bin/tailscaled
        - /etc/systemd/system/tailscaled.service
        - /etc/default/tailscaled
        - /usr/sbin/tailscale
        - /usr/sbin/tailscaled
      failed_when: false

    - name: Fail manual Tailscale installation
      ansible.builtin.fail:
        msg: "Manual Tailscale installation failed on {{ inventory_hostname }} and was rolled back."

  always:
    - name: Remove manual install artifacts
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      when: item != ""
      loop:
        - "{{ common_tailscale_manual_archive_path | default('') }}"
        - "{{ common_tailscale_manual_extract_dir | default('') }}"

# --- Official installer path for hosts without geo restrictions ---
- name: Download and install Tailscale if missing (non-RU, non-check mode)
  ansible.builtin.shell: | # noqa command-instead-of-module
    set -o pipefail
    curl -fsSL https://tailscale.com/install.sh | sh
  args:
    warn: false
    creates: /usr/bin/tailscale
  when:
    - "'region_ru' not in group_names"
    - not ansible_check_mode
    - common_tailscale_needs_install | default(true)
  register: common_tailscale_install_result
  # todo: Pin installer version and verify checksum/signature before execution

# ---- tailscale up ----

# At this point binaries exist on every host, so configure the daemon uniformly
- name: Bring up tailscale connection (non-check mode)
  ansible.builtin.command: >
    tailscale up
    --reset
    --login-server={{ common_tailscale_login_server }}
    --authkey={{ common_tailscale_authkey }}
    --ssh
    --hostname={{ inventory_hostname }}
    --operator={{ common_user_name }}
    --accept-dns
    --accept-routes
    --advertise-connector
    --advertise-exit-node
  when:
    - not ansible_check_mode
  register: common_tailscale_up_result
  changed_when: "'already' not in (common_tailscale_up_result.stdout | default(''))"
  # todo: Skip tailscale up when prefs already match and gate flags (--reset/exit-node/connector) behind variables

- name: Check tailscale presence and show intended up command (check mode)
  ansible.builtin.command: tailscale status
  register: common_tailscale_status_check_result
  changed_when: false
  failed_when: common_tailscale_status_check_result.rc != 0
  when:
    - ansible_check_mode

# ---- exit-node LAN access ----

- name: Gather Tailscale preferences (non-check mode)
  ansible.builtin.command: tailscale debug prefs
  register: common_tailscale_prefs_raw
  changed_when: false
  failed_when: common_tailscale_prefs_raw.rc != 0
  when:
    - not ansible_check_mode

- name: Parse Tailscale preferences (non-check mode)
  ansible.builtin.set_fact:
    common_tailscale_prefs: "{{ common_tailscale_prefs_raw.stdout | default('{}') | from_json }}"
  when:
    - not ansible_check_mode

- name: Determine exit-node LAN access state (non-check mode)
  ansible.builtin.set_fact:
    common_tailscale_exit_node_allow_lan: "{{ common_tailscale_prefs.ExitNodeAllowLANAccess | default(false) }}"
    common_tailscale_current_hostname: "{{ common_tailscale_prefs.Hostname | default('') }}"
  when:
    - not ansible_check_mode

- name: Ensure Tailscale hostname matches inventory name (non-check mode)
  ansible.builtin.command: >
    tailscale set --hostname={{ inventory_hostname }}
  register: common_tailscale_hostname_set
  changed_when: common_tailscale_hostname_set.rc == 0
  failed_when: common_tailscale_hostname_set.rc != 0
  when:
    - not ansible_check_mode
    - common_tailscale_current_hostname is defined
    - common_tailscale_current_hostname != inventory_hostname

- name: Allow LAN access on exit-node (non-check mode)
  ansible.builtin.command: >
    tailscale set --exit-node-allow-lan-access
  register: common_tailscale_exit_node_set_result
  changed_when: common_tailscale_exit_node_set_result.rc == 0
  failed_when: common_tailscale_exit_node_set_result.rc != 0
  when:
    - not ansible_check_mode
    - common_tailscale_exit_node_allow_lan is defined
    - not common_tailscale_exit_node_allow_lan

- name: Show would-be tailscale set command (check mode)
  ansible.builtin.debug:
    msg: >
      Would run on {{ inventory_hostname }}:
      tailscale set --exit-node-allow-lan-access
  when:
    - ansible_check_mode

# ---- status ----

- name: Show tailscale status (non-check mode)
  ansible.builtin.command: tailscale status
  register: common_tailscale_status_result
  changed_when: false
  when:
    - not ansible_check_mode

- name: Debug tailscale status (non-check mode)
  ansible.builtin.debug:
    var: common_tailscale_status_result.stdout
  when:
    - not ansible_check_mode
